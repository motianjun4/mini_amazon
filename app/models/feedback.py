from asyncio.windows_events import NULL
from sqlite3 import OperationalError
from tkinter import SE
from flask import current_app as app
import time
'''
CREATE TABLE IF NOT EXISTS public.review
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    uid integer NOT NULL,
    type integer NOT NULL,
    upid integer NOT NULL,
    rate integer NOT NULL,
    review text NOT NULL,
    create_at timestamp NOT NULL DEFAULT NOW(),
    CONSTRAINT feedbacks_pkey PRIMARY KEY (id)
);
'''
'''
CREATE TABLE IF NOT EXISTS public.review_like
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    rid integer NOT NULL,
    uid integer NOT NULL,
    is_up integer NOT NULL,
    CONSTRAINT reviews_pkey PRIMARY KEY (id)
);
'''
'''
type+upid 决定 是对商品还是商家的评价, type: 0为商品, 1为商家
rid 引用review.id, is_up 好评为1,差评为0
'''

class Review:
    def __init__(self, id, uid, type, upid, rate, review, create_at):
        self.id = id
        self.uid = uid
        self.type = type
        self.upid = upid
        self.rate = rate
        self.review = review
        self.create_at = create_at

    @staticmethod
    def submit(uid, type, upid, rate, review):
        app.db.execute('''
INSERT INTO review(uid, type, upid, rate, review)
VALUES(:uid, :type, :upid, :rate, :review)
        ''', uid=uid, type=type, upid=upid, rate=rate, review=review)

    @staticmethod
    def edit(uid, type, upid, rate, review):
        app.db.execute('''
UPDATE review
SET rate = :rate, review = :review, create_at=NULL
WHERE uid = :uid
AND upid = :upid
AND type = :type
        ''', uid=uid, upid=upid, rate=rate, review=review, type=type)

    @staticmethod
    def delete(uid, upid, type):
        app.db.execute('''
DELETE FROM review
WHERE uid = :uid
AND upid = :upid
AND type = :type
        ''', uid=uid, upid=upid, type=type)

    @staticmethod
    def user_show_reviews(uid, type):
        rows =app.db.execute('''
SELECT *
FROM review
WHERE uid = :uid
AND type = :type
ORDER BY timestamp DESC limit 5
        ''', uid=uid, type=type)
        return [Review(*row) for row in rows]

    @staticmethod
    def seller_show_reviews(upid, type):
        sql = '''
SELECT review.id, review.type, review.upid, review.rate, review.review, review.create_at,
SUM(is_up) AS like_cnt, COUNT(*)-like_cnt AS dislike_cnt
FROM review
LEFT JOIN review_like ON review_like.rid = review.id
GROUP BY rid
WHERE review.upid=:upid AND review.type=:type
'''
        rows_first = app.db.execute(sql+"ORDER BY like_cnt DESC limit 3")
        rows_second = app.db.execute(sql+"ORDER BY create_at DESC limit 5")
        for row in rows_second:
            if row not in rows_first and len(rows_first) <= 5:
                rows_first.append(row)
        return rows_first

class ReviewLike:
    def __init__(self, id, rid, uid, is_up):
        self.id = id
        self.rid = rid
        self.uid = uid
        self.is_up = is_up

    @staticmethod
    def insert(rid, uid, is_up):
        app.db.execute('''
INSERT INTO review_like(rid, uid, is_up)
VALUES(:rid, :uid, :is_up)
        ''', rid=rid, uid=uid, is_up=is_up)

    @staticmethod
    def delete(rid, uid):
        app.db.execute('''
DELETE FROM review_like
WHERE rid=:rid, uid=:uid
        ''', rid=rid, uid=uid)

    @staticmethod
    def is_like(rid, uid):
        rows = app.db.execute('''
SELECT is_up FROM review_like
WHERE rid=:rid, uid=:uid
        ''', rid=rid, uid=uid)
        if len(rows) == 0:
            return NULL
        return rows[0][0]